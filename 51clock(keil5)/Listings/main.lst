C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC89C5xRC.H>
   2          #include <intrins.h>
   3          #define uchar unsigned char
   4          #define uint unsigned int
   5          #define DS18B20_SKIP_ROM 0xCC
   6          #define DS18B20_CONVERT_T 0x44
   7          #define DS18B20_READ_SCRATCHPAD 0xBE 
   8          
   9          sbit onewire_dq = P3^7;//温度传感器引脚
  10          float T;//温度初始数据
  11          
  12          //数码管段选
  13          uchar table[] = {0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF};//0~9,-
  14          uchar table_dot[] = {0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,0x00,0x10,0xBF};//带小数点0~9,-
  15          
  16          sbit BEEP=P1^5;//蜂鸣器
  17          
  18          uchar whereNow; //0:时钟界面；1:调时界面；2:闹钟界面；3:日历界面；4:秒表界面；5:温度界面
  19          
  20          sbit K1=P1^0;//五个独立按键
  21          sbit K2=P1^1;
  22          sbit K3=P1^2;
  23          sbit K4=P1^3;
  24          sbit K5=P1^4;
  25           
  26          #define shanCount 128//选中位置闪烁计数标志
  27          uchar blankCount;//空白显示 计数标志
  28          uchar normalCount;//正常显示 计数标志
  29          
  30          uchar shi=0,fen=0,miao=0; //时钟时、分、秒 初始数据
  31          
  32          uchar clockSetLocation;//记录调时选中的位置 0,不闪烁,且无法使用加减按钮
  33          
  34          uchar alarmSetLocation;//记录闹钟设置时的所选位置
  35          uchar shi1=0,fen1=0,miao1=5;//闹钟时、分、秒 初始数据 
  36          bit alarmOnOff;//表明闹钟是否开启
  37          bit alarmSetOrNot;//表明是否正在设置闹钟
  38          uchar cldSetLocation;//记录闹钟设置时的所选位置
  39          
  40          uint year=2025; //日历 年 初始数据
  41          uchar month=12,day=28;//日历 月、日 初始数据
  42          #define minYear 2020//设定日历可显示的年份上下限
  43          #define maxYear 2050
  44          bit isLeapYear; //表明是否是闰年 1，是；0，否。
  45          bit cldSetOrNot;//表明是否正在设置日历
  46          uchar commonYearTable[]={0,31,28,31,30,31,30,31,31,30,31,30,31};//记录平年每个月有多少天
  47          uchar leapYearTable[]={0,31,29,31,30,31,30,31,31,30,31,30,31};  //记录闰年每个月有多少天
  48          
  49          uint stopwatch_time_fen = 0,stopwatch_time_miao = 0,stopwatch_time_miao_2 = 0;//秒表累计时间（毫秒）
  50          uchar stopwatch_state = 0;  //0-停止，1-运行，2-暂停
  51          uint watch_count = 0;
  52          
  53          void delay1ms(unsigned int xms) //@12.000MHz
  54          {
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 2   

  55   1        unsigned char data i, j;
  56   1        while(xms--)
  57   1        {
  58   2          i = 2;
  59   2          j = 239;
  60   2          do
  61   2          {
  62   3            while (--j);
  63   3          } while (--i);
  64   2        }
  65   1      }
  66          
  67          unsigned char onewire_Init()
  68          {
  69   1        unsigned char i;
  70   1        unsigned char AckBit;
  71   1        onewire_dq = 1;
  72   1        onewire_dq = 0;
  73   1        i = 247;
  74   1        while (--i);//delay 500us
  75   1        onewire_dq = 1;
  76   1        i = 32;
  77   1        while (--i);//delay 70us
  78   1        AckBit = onewire_dq;
  79   1        i = 247;
  80   1        while (--i);//delay 500us
  81   1        return AckBit;
  82   1      }
  83          
  84          void onewire_sendbit(uchar Bit)
  85          {
  86   1        unsigned char i;
  87   1        onewire_dq = 0;
  88   1        i = 4;
  89   1        while (--i);//delay 10us
  90   1        onewire_dq = Bit;
  91   1        i = 24;
  92   1        while (--i);//delay 50us
  93   1        onewire_dq = 1;
  94   1      }
  95          
  96          unsigned char onewire_receivebit()
  97          {
  98   1        unsigned char i;
  99   1        unsigned char Bit;
 100   1        onewire_dq = 0;
 101   1        i = 2;
 102   1        while (--i);//delay 5us
 103   1        onewire_dq = 1;
 104   1        i = 2;
 105   1        while (--i);//delay 5us
 106   1        Bit = onewire_dq;
 107   1        i = 24;
 108   1        while (--i);//delay 50us
 109   1        return Bit;
 110   1      }
 111          
 112          void onewire_sendbyte(uchar Byte)
 113          {
 114   1        unsigned char i;
 115   1        for(i = 0;i < 8;i++)
 116   1        {
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 3   

 117   2          onewire_sendbit(Byte & (0x01 << i));
 118   2        }
 119   1      }
 120          
 121          unsigned char onewire_receivebyte()
 122          {
 123   1        unsigned char i;
 124   1        unsigned char Byte = 0x00;
 125   1        for(i = 0;i < 8;i++)
 126   1        {
 127   2          if(onewire_receivebit())
 128   2          {
 129   3            Byte |= (0x01 << i);
 130   3          }
 131   2        }
 132   1        return Byte;
 133   1      }
 134          
 135          void DS18B20_ConvertT()
 136          {
 137   1        onewire_Init();
 138   1        onewire_sendbyte(DS18B20_SKIP_ROM);
 139   1        onewire_sendbyte(DS18B20_CONVERT_T);
 140   1      }
 141          
 142          float DS18B20_ReadT()
 143          {
 144   1        uchar TLSB,TMSB;
 145   1        int Temp;
 146   1        float T;
 147   1        onewire_Init();
 148   1        onewire_sendbyte(DS18B20_SKIP_ROM);
 149   1        onewire_sendbyte(DS18B20_READ_SCRATCHPAD);
 150   1        TLSB = onewire_receivebyte();
 151   1        TMSB = onewire_receivebyte();
 152   1        Temp = (TMSB << 8) | TLSB;
 153   1        T = Temp *0.0625;
 154   1        return T;
 155   1      }
 156          
 157          void Timer0_Init(void)    //1毫秒@12.000MHz
 158          {
 159   1        AUXR &= 0x7F;     //定时器时钟12T模式
 160   1        TMOD &= 0xF0;     //设置定时器模式
 161   1        TMOD |= 0x01;     //设置定时器模式
 162   1        TL0 = 0x18;       //设置定时初始值
 163   1        TH0 = 0xFC;       //设置定时初始值
 164   1        TF0 = 0;        //清除TF0标志
 165   1        TR0 = 1;        //定时器0开始计时
 166   1        ET0 = 1;        //使能定时器0中断
 167   1        EA = 1;
 168   1      }
 169          
 170          void Timer0_Isr(void) interrupt 1
 171          {
 172   1        static uint count=0;
 173   1        TL0 = 0x18;       //设置定时初始值
 174   1        TH0 = 0xFC;       //设置定时初始值
 175   1        count++;//定时器计数标志+1
 176   1        
 177   1        if(whereNow == 4 && stopwatch_state == 1) // 在秒表界面且正在运行
 178   1        {
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 4   

 179   2          watch_count++;
 180   2          
 181   2          if(10 == watch_count)
 182   2          {
 183   3            stopwatch_time_miao_2++;// 增加10毫秒（0.01秒）
 184   3            watch_count=0;
 185   3          }
 186   2          if(100 ==stopwatch_time_miao_2)
 187   2          {
 188   3            stopwatch_time_miao++;
 189   3            stopwatch_time_miao_2=0;
 190   3          }
 191   2          if(60 == stopwatch_time_miao)
 192   2          {
 193   3            stopwatch_time_fen++;
 194   3            stopwatch_time_miao=0;
 195   3          }
 196   2          if(60 == stopwatch_time_fen)
 197   2          {
 198   3            stopwatch_time_fen=0;
 199   3          }
 200   2        }
 201   1        
 202   1        if(1000==count)//定时器次数达到1000次，秒+1
 203   1        {
 204   2          miao++;
 205   2          T = DS18B20_ReadT();
 206   2          count=0;//定时器次数清零
 207   2        }
 208   1        if(60==miao)//秒计数达到60次，分+1
 209   1        {
 210   2          fen++;
 211   2          miao=0;//秒计数清零
 212   2        }
 213   1        if(60==fen)//分计数达到60次，时+1
 214   1        {
 215   2          shi++;
 216   2          fen=0;//分计数清零
 217   2        }
 218   1        if(24==shi)//时计数达到24次，日+1
 219   1        {   
 220   2          day++;
 221   2          shi=0;//时计数清零
 222   2        } 
 223   1        if(0==isLeapYear)//如果是平年 
 224   1        { 
 225   2          if(day>commonYearTable[month])
 226   2          {
 227   3             day=1;//如果日计数超过本月天数，则变为1
 228   3             month++;
 229   3          }
 230   2        }
 231   1        else      //如果是闰年
 232   1        {
 233   2          if(day>leapYearTable[month])
 234   2          {
 235   3             day=1;//如果日计数超过本月天数，则变为1
 236   3             month++;
 237   3          }
 238   2        }   
 239   1        if(month>12)
 240   1        {
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 5   

 241   2          month=1;//如果月计数超过12，则变为1
 242   2          year++;
 243   2        }
 244   1        if(year>maxYear)
 245   1        {
 246   2          year=minYear;//如果年计数超过一定限度，则变为最低限度年份
 247   2        }
 248   1      }
 249          
 250          void is_leap_year()//--------------------------判断是否是闰年
 251          {
 252   1        if((year%4==0 && year%100!=0) || (year%400==0))
 253   1        isLeapYear=1;
 254   1        else
 255   1        isLeapYear=0;
 256   1      }
 257          
 258          void smg(uchar Location,Number)//数码管单个位置亮一下
 259          {
 260   1        switch(Location)
 261   1        {
 262   2          case 1:P0 = 0xFE;break;
 263   2          case 2:P0 = 0xFD;break;
 264   2          case 3:P0 = 0xFB;break;
 265   2          case 4:P0 = 0xF7;break;
 266   2          case 5:P0 = 0xEF;break;
 267   2          case 6:P0 = 0xDF;break;
 268   2          case 7:P0 = 0xBF;break;
 269   2          case 8:P0 = 0x7F;break;
 270   2        }
 271   1        P2 = Number; 
 272   1        delay1ms(1);
 273   1        P2 = 0xFF;
 274   1      }
 275          
 276          void clock_display()//-------------------------数码管动态显示时钟界面
 277          {
 278   1        //时的十位 
 279   1          //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 280   1          if(1 == clockSetLocation && blankCount>0)
 281   1          {
 282   2            smg(1,0xFF);
 283   2            blankCount--;
 284   2          }
 285   1          //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 286   1          else if(1 == clockSetLocation && normalCount>0)
 287   1          {
 288   2            smg(1,table[shi/10]);
 289   2            normalCount--;
 290   2          }
 291   1          else if(1 == clockSetLocation)
 292   1          {
 293   2            blankCount = shanCount;//闪烁标志初始化
 294   2            normalCount = shanCount;  
 295   2          }
 296   1          else
 297   1          smg(1,table[shi/10]);
 298   1      
 299   1        //时的个位 
 300   1          //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 301   1          if(1 == clockSetLocation && blankCount>0)
 302   1          {
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 6   

 303   2            smg(2,0xFF);
 304   2            blankCount--;
 305   2          }
 306   1          //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 307   1          else if(1 == clockSetLocation && normalCount>0)
 308   1          {
 309   2            smg(2,table[shi%10]);
 310   2            normalCount--;
 311   2          }
 312   1          else if(1 == clockSetLocation)
 313   1          {
 314   2            blankCount = shanCount;//闪烁标志初始化
 315   2            normalCount = shanCount;  
 316   2          }
 317   1          else
 318   1          smg(2,table[shi%10]);
 319   1      
 320   1        //- 
 321   1          smg(3,table[10]);
 322   1      
 323   1        //分的十位 
 324   1          //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 325   1          if(2==clockSetLocation && blankCount>0)
 326   1          {
 327   2            smg(4,0xFF);
 328   2            blankCount--;
 329   2          }
 330   1          //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 331   1          else if(2 == clockSetLocation && normalCount > 0)
 332   1          {
 333   2            smg(4,table[fen/10]);
 334   2            normalCount--;
 335   2          }
 336   1          else if(2 == clockSetLocation)
 337   1          {
 338   2            blankCount = shanCount;//闪烁标志初始化
 339   2            normalCount = shanCount;  
 340   2          }
 341   1          else
 342   1          smg(4,table[fen/10]);
 343   1      
 344   1        //分的个位 
 345   1          //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 346   1          if(2 == clockSetLocation && blankCount>0)
 347   1          {
 348   2            smg(5,0xFF);
 349   2            blankCount--;
 350   2          }
 351   1          //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 352   1          else if(2 == clockSetLocation && normalCount>0)
 353   1          {
 354   2            smg(5,table[fen%10]);
 355   2            normalCount--;
 356   2          }
 357   1          else if(2 == clockSetLocation)
 358   1          {
 359   2            blankCount = shanCount;//闪烁标志初始化
 360   2            normalCount = shanCount;  
 361   2          }
 362   1          else
 363   1          smg(5,table[fen%10]);
 364   1      
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 7   

 365   1        //- 
 366   1          smg(6,table[10]);
 367   1      
 368   1        //秒的十位 
 369   1          //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 370   1          if(3 == clockSetLocation && blankCount>0)
 371   1          {
 372   2            smg(7,0xFF);
 373   2            blankCount--;
 374   2          }
 375   1          //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 376   1          else if(3 == clockSetLocation && normalCount>0)
 377   1          {
 378   2            smg(7,table[miao/10]);
 379   2            normalCount--;
 380   2          }
 381   1          else if(3 == clockSetLocation)
 382   1          {
 383   2            blankCount = shanCount;//闪烁标志初始化
 384   2            normalCount = shanCount;  
 385   2          }
 386   1          else
 387   1          smg(7,table[miao/10]);
 388   1      
 389   1        //秒的个位 
 390   1          //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 391   1          if(3 == clockSetLocation && blankCount>0)
 392   1          {
 393   2            smg(8,0xFF);
 394   2            blankCount--;
 395   2          }
 396   1          //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 397   1          else if(3 == clockSetLocation && normalCount>0)
 398   1          {
 399   2            smg(8,table[miao%10]);
 400   2            normalCount--;
 401   2          }
 402   1          else if(3 == clockSetLocation)
 403   1          {
 404   2            blankCount = shanCount;//闪烁标志初始化
 405   2            normalCount = shanCount;  
 406   2          }
 407   1          else
 408   1          smg(8,table[miao%10]);
 409   1      }
 410          
 411          void clock_set()//--------------------------调时(与时钟同界面)
 412          {
 413   1        if(0==K1 && 0==whereNow)  //如果此时在时钟界面并按下了调时按键K1
 414   1        {
 415   2          delay1ms(20);//消抖
 416   2          if(0==K1)//再次检测按键状态
 417   2          { 
 418   3            while(0==K1);//长按等待
 419   3            delay1ms(20);//消抖
 420   3            whereNow=1;
 421   3            clockSetLocation=1;
 422   3            TR0=0;
 423   3          }
 424   2        }
 425   1        if(1==whereNow) //进入调时界面，4个独立按键化身为调时相关按钮
 426   1        {
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 8   

 427   2          if(0==K1)//如果按下K1:调整位置
 428   2          {
 429   3            delay1ms(20);//消抖
 430   3            if(0==K1)//再次检测按键状态
 431   3            {  
 432   4              while(0==K1);//长按停留在此
 433   4              delay1ms(20);//消抖
 434   4              clockSetLocation++;//位置标志+1
 435   4              if(clockSetLocation>3)
 436   4                clockSetLocation=1;
 437   4            }
 438   3          }
 439   2      
 440   2            if(1==clockSetLocation)//进行“时”加减
 441   2            {
 442   3              if(0==K2)//按下K2：数字-1
 443   3              {
 444   4                delay1ms(20);//消抖
 445   4                if(0==K2)//再次检测按键状态
 446   4                {  
 447   5                  while(0==K2);//长按停留在此
 448   5                  delay1ms(20);//消抖
 449   5                  if(0==shi)
 450   5                    shi=24;
 451   5                  shi--;
 452   5                } 
 453   4              }
 454   3              if(0==K3)//按下K3：数字+1
 455   3              {
 456   4                delay1ms(20);//消抖
 457   4                if(0==K3)//再次检测按键状态
 458   4                {  
 459   5                  while(0==K3);//长按停留在此
 460   5                  delay1ms(20);//消抖
 461   5                  shi++;
 462   5                  if(24==shi)
 463   5                    shi=0;
 464   5                } 
 465   4              }
 466   3            }
 467   2      
 468   2            if(2==clockSetLocation)//进行“分”加减
 469   2            {
 470   3              if(0==K2)//按下K2：数字-1
 471   3              {
 472   4                delay1ms(20);//消抖
 473   4                if(0==K2)//再次检测按键状态
 474   4                {  
 475   5                  while(0==K2);//长按停留在此
 476   5                  delay1ms(20);//消抖
 477   5                  if(0==fen)
 478   5                    fen=60;
 479   5                  fen--;
 480   5                } 
 481   4              }
 482   3              if(0==K3)//按下K3：数字+1
 483   3              {
 484   4                delay1ms(20);//消抖
 485   4                if(0==K3)//再次检测按键状态
 486   4                {  
 487   5                  while(0==K3);//长按停留在此
 488   5                  delay1ms(20);//消抖
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 9   

 489   5                  fen++;
 490   5                  if(60==fen)
 491   5                    fen=0;
 492   5                } 
 493   4              }
 494   3            }
 495   2      
 496   2            if(3==clockSetLocation)//进行“秒”加减
 497   2            {
 498   3              if(0==K2)//按下K2：数字-1
 499   3              {
 500   4                delay1ms(20);//消抖
 501   4                if(0==K2)//再次检测按键状态
 502   4                {  
 503   5                  while(0==K2);//长按停留在此
 504   5                  delay1ms(20);//消抖
 505   5                  if(0==miao)
 506   5                    miao=60;
 507   5                  miao--;
 508   5                } 
 509   4              }
 510   3              if(0==K3)//按下K3：数字+1
 511   3              {
 512   4                delay1ms(20);//消抖
 513   4                if(0==K3)//再次检测按键状态
 514   4                {  
 515   5                  while(0==K3);//长按停留在此
 516   5                  delay1ms(20);//消抖
 517   5                  miao++;
 518   5                  if(60==miao)
 519   5                    miao=0;
 520   5                } 
 521   4              }
 522   3            } 
 523   2         
 524   2          if(0==K4)//如果按下K4：确认并退出调时模式，然后返回时钟界面
 525   2          {
 526   3            delay1ms(20);//消抖
 527   3            if(0==K4)//再次检测按键状态
 528   3            {  
 529   4              while(0==K4);//长按停留在此
 530   4              delay1ms(20);//消抖
 531   4              clockSetLocation=0;
 532   4              whereNow=0;
 533   4              TR0=1;
 534   4            }
 535   3          } 
 536   2        }
 537   1      }
 538          
 539          void alarm_display()//----------------------数码管动态显示闹钟界面
 540          {
 541   1        if(0==alarmOnOff)//如果闹钟关闭
 542   1          smg(1,0x8C);//'P.'表示STOP,闹钟关闭
 543   1        if(1==alarmOnOff)//如果闹钟开启
 544   1          smg(1,0x86);//'E.'表示OPEN,闹钟开
 545   1        
 546   1      //时的十位
 547   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 548   1        if(1 == alarmSetLocation && blankCount>0)
 549   1        {
 550   2          smg(3,0xFF);
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 10  

 551   2          blankCount--;
 552   2        }
 553   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 554   1        else if(1 == alarmSetLocation && normalCount>0)
 555   1        {
 556   2          smg(3,table[shi1/10]);
 557   2          normalCount--;
 558   2        }
 559   1        else if(1 == alarmSetLocation)
 560   1        {
 561   2          blankCount=shanCount;//闪烁标志初始化
 562   2          normalCount=shanCount;  
 563   2        }
 564   1        else
 565   1        smg(3,table[shi1/10]);
 566   1        
 567   1      //时的个位
 568   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 569   1        if(1 == alarmSetLocation && blankCount>0)
 570   1        {
 571   2          smg(4,0xFF);
 572   2          blankCount--;
 573   2        }
 574   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 575   1        else if(1 == alarmSetLocation && normalCount>0)
 576   1        {
 577   2          smg(4,table_dot[shi1%10]);
 578   2          normalCount--;
 579   2        }
 580   1        else if(1 == alarmSetLocation)
 581   1        {
 582   2          blankCount=shanCount;//闪烁标志初始化
 583   2          normalCount=shanCount;  
 584   2        }
 585   1        else
 586   1        smg(4,table_dot[shi1%10]);
 587   1      //分的十位
 588   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 589   1        if(2 == alarmSetLocation && blankCount>0)
 590   1        {
 591   2          smg(5,0xFF);
 592   2          blankCount--;
 593   2        }
 594   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 595   1        else if(2 == alarmSetLocation && normalCount>0)
 596   1        {
 597   2          smg(5,table[fen1/10]);
 598   2          normalCount--;
 599   2        }
 600   1        else if(2==alarmSetLocation)
 601   1        {
 602   2          blankCount=shanCount;//闪烁标志初始化
 603   2          normalCount=shanCount;  
 604   2        }
 605   1        else
 606   1        smg(5,table[fen1/10]);
 607   1        
 608   1      //分的个位
 609   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 610   1        if(2 == alarmSetLocation && blankCount>0)
 611   1        {
 612   2          smg(6,0xFF);
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 11  

 613   2          blankCount--;
 614   2        }
 615   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 616   1        else if(2 == alarmSetLocation && normalCount>0)
 617   1        {
 618   2          smg(6,table_dot[fen1%10]);
 619   2          normalCount--;
 620   2        }
 621   1        else if(2 == alarmSetLocation)
 622   1        {
 623   2          blankCount=shanCount;//闪烁标志初始化
 624   2          normalCount=shanCount;  
 625   2        }
 626   1        else
 627   1        smg(6,table_dot[fen1%10]);
 628   1        
 629   1      //秒的十位
 630   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 631   1        if(3 == alarmSetLocation && blankCount>0)
 632   1        {
 633   2          smg(7,0xFF);
 634   2          blankCount--;
 635   2        }
 636   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 637   1        else if(3 == alarmSetLocation && normalCount>0)
 638   1        {
 639   2          smg(7,table[miao1/10]);
 640   2          normalCount--;
 641   2        }
 642   1        else if(3 == alarmSetLocation)
 643   1        {
 644   2          blankCount=shanCount;//闪烁标志初始化
 645   2          normalCount=shanCount;  
 646   2        }
 647   1        else
 648   1        smg(7,table[miao1/10]);
 649   1        
 650   1      //秒的个位
 651   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 652   1        if(3 == alarmSetLocation && blankCount>0)
 653   1        {
 654   2          smg(8,0xFF);
 655   2          blankCount--;
 656   2        }
 657   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 658   1        else if(3 == alarmSetLocation && normalCount>0)
 659   1        {
 660   2          smg(8,table_dot[miao1%10]);
 661   2          normalCount--;
 662   2        }
 663   1        else if(3==alarmSetLocation)
 664   1        {
 665   2          blankCount=shanCount;//闪烁标志初始化
 666   2          normalCount=shanCount;  
 667   2        }
 668   1        else
 669   1        smg(8,table_dot[miao1%10]);
 670   1      }
 671          
 672          void alarm_set()//----------------------闹钟设置
 673          {
 674   1        if(0==whereNow && 0==K2)//如果此时在时钟界面并按下了闹钟按键K2
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 12  

 675   1        {
 676   2          delay1ms(20);//消抖
 677   2          if(0==K2)//再次检测按键状态
 678   2          { 
 679   3            while(0==K2);//长按等待
 680   3            delay1ms(20);//消抖
 681   3            whereNow=2;
 682   3          }
 683   2        }
 684   1        
 685   1        if(2==whereNow)//如果此时在闹钟界面，那么四个独立按键化身为闹钟相关按键
 686   1        {
 687   2          if(0==K1)//如果按下K1:调整位置
 688   2          {
 689   3            delay1ms(20);//消抖
 690   3            if(0==K1)//再次检测按键状态
 691   3            {  
 692   4              while(0==K1);//长按停留在此
 693   4              delay1ms(20);//消抖
 694   4              alarmSetLocation++;//位置标志+1
 695   4              if(4==alarmSetLocation)
 696   4                alarmOnOff=!alarmOnOff;
 697   4              if(alarmSetLocation>3)
 698   4                alarmSetLocation=0;   
 699   4            }
 700   3          }   
 701   2      
 702   2            if(1==alarmSetLocation)//进行“时”加减
 703   2            {
 704   3              if(0==K2)//按下K2：数字-1
 705   3              {
 706   4                delay1ms(20);//消抖
 707   4                if(0==K2)//再次检测按键状态
 708   4                {  
 709   5                  while(0==K2);//长按停留在此
 710   5                  delay1ms(20);//消抖
 711   5                  if(0==shi1)shi1=24;
 712   5                  shi1--;
 713   5                } 
 714   4              }
 715   3              if(0==K3)//按下K3：数字+1
 716   3              {
 717   4                delay1ms(20);//消抖
 718   4                if(0==K3)//再次检测按键状态
 719   4                {  
 720   5                  while(0==K3);//长按停留在此
 721   5                  delay1ms(20);//消抖
 722   5                  shi1++;
 723   5                  if(24==shi1)shi1=0;
 724   5                } 
 725   4              }
 726   3            }
 727   2      
 728   2            if(2==alarmSetLocation)//进行“分”加减
 729   2            {
 730   3              if(0==K2)//按下K2：数字-1
 731   3              {
 732   4                delay1ms(20);//消抖
 733   4                if(0==K2)//再次检测按键状态
 734   4                {  
 735   5                  while(0==K2);//长按停留在此
 736   5                  delay1ms(20);//消抖
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 13  

 737   5                  if(0==fen1)fen1=60;
 738   5                  fen1--;
 739   5                } 
 740   4              }
 741   3              if(0==K3)//按下K3：数字+1
 742   3              {
 743   4                delay1ms(20);//消抖
 744   4                if(0==K3)//再次检测按键状态
 745   4                {  
 746   5                  while(0==K3);//长按停留在此
 747   5                  delay1ms(20);//消抖
 748   5                  fen1++;
 749   5                  if(60==fen1)fen1=0;
 750   5                } 
 751   4              }
 752   3            }
 753   2      
 754   2            if(3==alarmSetLocation)//进行“秒”加减
 755   2            {
 756   3              if(0==K2)//按下K2：数字-1
 757   3              {
 758   4                delay1ms(20);//消抖
 759   4                if(0==K2)//再次检测按键状态
 760   4                {  
 761   5                  while(0==K2);//长按停留在此
 762   5                  delay1ms(20);//消抖
 763   5                  if(0==miao1)miao1=60;
 764   5                  miao1--;
 765   5                } 
 766   4              }
 767   3              if(0==K3)//按下K3：数字+1
 768   3              {
 769   4                delay1ms(20);//消抖
 770   4                if(0==K3)//再次检测按键状态
 771   4                {  
 772   5                  while(0==K3);//长按停留在此
 773   5                  delay1ms(20);//消抖
 774   5                  miao1++;
 775   5                  if(60==miao1)miao1=0;
 776   5                } 
 777   4              } 
 778   3            }
 779   2      
 780   2            if(0==K4)//如果按下K4：确认并退出闹钟界面，然后返回时钟界面
 781   2              {
 782   3              delay1ms(20);//消抖
 783   3              if(0==K4)//再次检测按键状态
 784   3              {  
 785   4                while(0==K4);//长按停留在此
 786   4                delay1ms(20);//消抖
 787   4                alarmSetLocation=0;
 788   4                whereNow=0;
 789   4              }
 790   3            } 
 791   2        } 
 792   1      }
 793          
 794          void alarm_exe()//---------------------------------------------闹钟执行
 795          //只有当以下条件【都满足】的时候，闹钟才会响起：
 796          //1、时钟的时分秒=闹钟的时分秒
 797          //2、闹钟处于开启状态
 798          //3、当前在时钟运行界面
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 14  

 799          //
 800          //注：按下独立按键中的任意一个并松开，可停止闹钟
 801          { 
 802   1        if(shi==shi1 && fen==fen1 && miao==miao1 && 1==alarmOnOff && 0==whereNow)
 803   1        {
 804   2          while(1==K1 && 1==K2 && 1==K3 && 1==K4)
 805   2          {
 806   3          BEEP=~BEEP;
 807   3          smg(1,0x88);//'A'
 808   3            BEEP=~BEEP;
 809   3          smg(2,0x47);//'L.'
 810   3            BEEP=~BEEP;
 811   3          smg(3,table[shi1/10]);
 812   3            BEEP=~BEEP;
 813   3          smg(4,table_dot[shi1%10]);
 814   3            BEEP=~BEEP;
 815   3          smg(5,table[fen1/10]);
 816   3            BEEP=~BEEP;
 817   3          smg(6,table_dot[fen1%10]);
 818   3            BEEP=~BEEP;
 819   3          smg(7,table[miao1/10]);
 820   3            BEEP=~BEEP;
 821   3          smg(8,table[miao1%10]);
 822   3            BEEP=~BEEP;
 823   3          }
 824   2          while(0==K1 || 0==K2 || 0==K3 || 0==K4);//等待，直至松开独立按键
 825   2          delay1ms(20);
 826   2          BEEP=1;
 827   2        }
 828   1      }
 829          
 830          void cld_display()//------------------------数码管动态显示日历界面
 831          {
 832   1      //年的千位
 833   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 834   1        if(1 == cldSetLocation && blankCount>0)
 835   1        {
 836   2          smg(1,0xFF);
 837   2          blankCount--;
 838   2        }
 839   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 840   1        else if(1 == cldSetLocation && normalCount>0)
 841   1        {
 842   2          smg(1,table[year/1000]);
 843   2          normalCount--;
 844   2        }
 845   1        else if(1 == cldSetLocation)
 846   1        {
 847   2          blankCount=shanCount;//闪烁标志初始化
 848   2          normalCount=shanCount;  
 849   2        }
 850   1        else
 851   1        smg(1,table[year/1000]);
 852   1        
 853   1      //年的百位
 854   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 855   1        if(1 == cldSetLocation && blankCount>0)
 856   1        {
 857   2          smg(2,0xFF);
 858   2          blankCount--;
 859   2        }
 860   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 15  

 861   1        else if(1 == cldSetLocation && normalCount>0)
 862   1        {
 863   2          smg(2,table[year/100%10]);
 864   2          normalCount--;
 865   2        }
 866   1        else if(1 == cldSetLocation)
 867   1        {
 868   2          blankCount=shanCount;//闪烁标志初始化
 869   2          normalCount=shanCount;  
 870   2        }
 871   1        else
 872   1        smg(2,table[year/100%10]);
 873   1        
 874   1      //年的十位
 875   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 876   1        if(1 == cldSetLocation && blankCount>0)
 877   1        {
 878   2          smg(3,0xFF);
 879   2          blankCount--;
 880   2        }
 881   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 882   1        else if(1 == cldSetLocation && normalCount>0)
 883   1        {
 884   2          smg(3,table[year%100/10]);
 885   2          normalCount--;
 886   2        }
 887   1        else if(1 == cldSetLocation)
 888   1        {
 889   2          blankCount=shanCount;//闪烁标志初始化
 890   2          normalCount=shanCount;  
 891   2        }
 892   1        else
 893   1        smg(3,table[year%100/10]);
 894   1        
 895   1      //年的个位
 896   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 897   1        if(1 == cldSetLocation && blankCount>0)
 898   1        {
 899   2          smg(4,0xFF);
 900   2          blankCount--;
 901   2        }
 902   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 903   1        else if(1 == cldSetLocation && normalCount>0)
 904   1        {
 905   2          smg(4,table_dot[year%10]);
 906   2          normalCount--;
 907   2        }
 908   1        else if(1 == cldSetLocation)
 909   1        {
 910   2          blankCount=shanCount;//闪烁标志初始化
 911   2          normalCount=shanCount;  
 912   2        }
 913   1        else
 914   1        smg(4,table_dot[year%10]);
 915   1        
 916   1      //月的十位
 917   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 918   1        if(2 == cldSetLocation && blankCount>0)
 919   1        {
 920   2          smg(5,0xFF);
 921   2          blankCount--;
 922   2        }
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 16  

 923   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 924   1        else if(2 == cldSetLocation && normalCount>0)
 925   1        {
 926   2          smg(5,table[month/10]);
 927   2          normalCount--;
 928   2        }else if(2 == cldSetLocation)
 929   1        {
 930   2          blankCount=shanCount;//闪烁标志初始化
 931   2          normalCount=shanCount;  
 932   2        }
 933   1        else
 934   1        smg(5,table[month/10]);
 935   1        
 936   1      //月的个位
 937   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 938   1        if(2 == cldSetLocation && blankCount>0)
 939   1        {
 940   2          smg(6,0xFF);
 941   2          blankCount--;
 942   2        }
 943   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 944   1        else if(2 == cldSetLocation && normalCount>0)
 945   1        {
 946   2          smg(6,table_dot[month%10]);
 947   2          normalCount--;
 948   2        }
 949   1        else if(2==cldSetLocation)
 950   1        {
 951   2          blankCount=shanCount;//闪烁标志初始化
 952   2          normalCount=shanCount;  
 953   2        }
 954   1        else
 955   1        smg(6,table_dot[month%10]);
 956   1        
 957   1      //日的十位
 958   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 959   1        if(3 == cldSetLocation && blankCount>0)
 960   1        {
 961   2          smg(7,0xFF);
 962   2          blankCount--;
 963   2        }
 964   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 965   1        else if(3 == cldSetLocation && normalCount>0)
 966   1        {
 967   2          smg(7,table[day/10]);
 968   2          normalCount--;
 969   2        }
 970   1        else if(3 == cldSetLocation)
 971   1        {
 972   2          blankCount=shanCount;//闪烁标志初始化
 973   2          normalCount=shanCount;  
 974   2        }
 975   1        else
 976   1        smg(7,table[day/10]);
 977   1        
 978   1      //日的个位
 979   1        //如果正在调整此位置且闪烁空白计数不为0，则此位置继续空白显示
 980   1        if(3 == cldSetLocation && blankCount>0)
 981   1        {
 982   2          smg(8,0xFF);
 983   2          blankCount--;
 984   2        }
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 17  

 985   1        //如果正在调整此位置且闪烁正常计数不为0，则此位置继续正常显示
 986   1        else if(3 == cldSetLocation && normalCount>0)
 987   1        {
 988   2          smg(8,table_dot[day%10]);
 989   2          normalCount--;
 990   2        }
 991   1        else if(3 == cldSetLocation)
 992   1        {
 993   2          blankCount=shanCount;//闪烁标志初始化
 994   2          normalCount=shanCount;  
 995   2        }
 996   1        else
 997   1        smg(8,table_dot[day%10]); 
 998   1      }
 999          
1000          void cld_set()//---------------------------日历设置
1001          {
1002   1        if(0==whereNow && 0==K3)//如果此时在时钟界面并按下了日历按键K3
1003   1        {
1004   2          delay1ms(20);//消抖
1005   2          if(0==K3)//再次检测按键状态
1006   2          { 
1007   3            while(0==K3);//长按等待
1008   3            delay1ms(20);//消抖
1009   3            whereNow=3;
1010   3          }
1011   2        }
1012   1        
1013   1        if(3==whereNow)//如果此时在日历界面，那么四个独立按键化身为日历相关按键
1014   1        {
1015   2          if(0==K1)//如果按下K1:调整位置
1016   2          {
1017   3            delay1ms(20);//消抖
1018   3            if(0==K1)//再次检测按键状态
1019   3            {  
1020   4              while(0==K1);//长按停留在此
1021   4              delay1ms(20);//消抖
1022   4              cldSetLocation++;//位置标志+1
1023   4              if(cldSetLocation>3)
1024   4                cldSetLocation=1;   
1025   4            }
1026   3          }   
1027   2      
1028   2            if(1==cldSetLocation)//进行“年”加减
1029   2            {
1030   3              if(0==K2)//按下K2：数字-1
1031   3              {
1032   4                delay1ms(20);//消抖
1033   4                if(0==K2)//再次检测按键状态
1034   4                {  
1035   5                  while(0==K2);//长按停留在此
1036   5                  delay1ms(20);//消抖
1037   5                  if(minYear==year)
1038   5                    year=minYear+1;//设定日历年份减到最低限度则无法再减
1039   5                  year--;
1040   5                } 
1041   4              }
1042   3              if(0==K3)//按下K3：数字+1
1043   3              {
1044   4                delay1ms(20);//消抖
1045   4                if(0==K3)//再次检测按键状态
1046   4                {  
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 18  

1047   5                  while(0==K3);//长按停留在此
1048   5                  delay1ms(20);//消抖
1049   5                  year++;
1050   5                  if(maxYear+1==year)
1051   5                    year=maxYear;//设定日历年份加到最大限度则无法再加
1052   5                } 
1053   4              }
1054   3            }
1055   2      
1056   2            if(2==cldSetLocation)//进行“月”加减
1057   2            {
1058   3              if(0==K2)//按下K2：数字-1
1059   3              {
1060   4                delay1ms(20);//消抖
1061   4                if(0==K2)//再次检测按键状态
1062   4                {  
1063   5                  while(0==K2);//长按停留在此
1064   5                  delay1ms(20);//消抖
1065   5                  if(1==month)
1066   5                    month=13;
1067   5                  month--;
1068   5                } 
1069   4              }
1070   3              if(0==K3)//按下K3：数字+1
1071   3              {
1072   4                delay1ms(20);//消抖
1073   4                if(0==K3)//再次检测按键状态
1074   4                {  
1075   5                  while(0==K3);//长按停留在此
1076   5                  delay1ms(20);//消抖
1077   5                  month++;
1078   5                  if(13==month)
1079   5                    month=1;
1080   5                } 
1081   4              }
1082   3            }
1083   2      
1084   2            if(3==cldSetLocation)//进行“日”加减
1085   2            {
1086   3              if(0==K2)//按下K2：数字-1
1087   3              {
1088   4                delay1ms(20);//消抖
1089   4                if(0==K2)//再次检测按键状态
1090   4                {  
1091   5                  while(0==K2);//长按停留在此
1092   5                  delay1ms(20);//消抖
1093   5                  if(day<=1)
1094   5                  {         
1095   6                    if(0==isLeapYear)//如果是平年
1096   6                      day=commonYearTable[month]+1;
1097   6                    if(1==isLeapYear)//如果是闰年
1098   6                      day=leapYearTable[month]+1; 
1099   6                  } 
1100   5                  day--;
1101   5                } 
1102   4              }
1103   3              if(0==K3)//按下K3：数字+1
1104   3              {
1105   4                delay1ms(20);//消抖
1106   4                if(0==K3)//再次检测按键状态
1107   4                {  
1108   5                  while(0==K3);//长按停留在此
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 19  

1109   5                  delay1ms(20);//消抖
1110   5                  day++;          
1111   5                  if(0==isLeapYear)//如果是平年
1112   5                  {
1113   6                    if(day>commonYearTable[month])
1114   6                      day=1;
1115   6                  }
1116   5                  if(1==isLeapYear)//如果是闰年
1117   5                  {
1118   6                    if(day>leapYearTable[month])
1119   6                      day=1;
1120   6                  }
1121   5                } 
1122   4              } 
1123   3            }
1124   2      
1125   2            if(0==K4)//如果按下K4：确认并退出日历界面，然后返回时钟界面
1126   2              {
1127   3              delay1ms(20);//消抖
1128   3              if(0==K4)//再次检测按键状态
1129   3              {  
1130   4                while(0==K4);//长按停留在此
1131   4                delay1ms(20);//消抖
1132   4                cldSetLocation=0;
1133   4                whereNow=0;
1134   4              }
1135   3            } 
1136   2        }   
1137   1      }
1138          
1139          void stopwatch_display()
1140          {
1141   1          smg(1,table[stopwatch_time_fen/10]);
1142   1          smg(2,table[stopwatch_time_fen%10]);
1143   1          smg(3,table[10]);
1144   1          smg(4,table[stopwatch_time_miao/10]);
1145   1          smg(5,table_dot[stopwatch_time_miao%10]);
1146   1          smg(6,table[10]);
1147   1          smg(7,table[stopwatch_time_miao_2/10]);
1148   1          smg(8,table[stopwatch_time_miao_2%10]);
1149   1      }
1150          
1151          void stopwatch_set()
1152          {
1153   1        if(0==whereNow && 0==K5)//如果此时在时钟界面并按下了秒表按键K5
1154   1        {
1155   2          delay1ms(20);//消抖
1156   2          if(0==K5)//再次检测按键状态
1157   2          { 
1158   3            while(0==K5);//长按等待
1159   3            delay1ms(20);//消抖
1160   3            whereNow=4;
1161   3          }
1162   2        }
1163   1        if(4==whereNow)
1164   1        {
1165   2          if(K1== 0)  // 如果按下K1
1166   2          { 
1167   3            delay1ms(20);  // 消抖
1168   3            if(K1 == 0) // 再次检测按键状态
1169   3            {  
1170   4              while(K1 == 0);  // 等待按键释放
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 20  

1171   4              delay1ms(20);  // 消抖
1172   4              if(stopwatch_state == 0 || stopwatch_state == 2)// 如果当前是停止或暂停状态
1173   4              {  
1174   5                stopwatch_state = 1;  // 开始运行
1175   5              } 
1176   4              else if(stopwatch_state == 1)// 如果当前是运行状态
1177   4              {  
1178   5                stopwatch_state = 2;  // 暂停
1179   5              }
1180   4            }
1181   3          }
1182   2          
1183   2          if(0 == K2)  // 如果按下K2
1184   2          { 
1185   3            delay1ms(20);  // 消抖
1186   3            if(0 == K2) // 再次检测按键状态
1187   3            {  
1188   4              while(0 == K2);  // 等待按键释放
1189   4              delay1ms(20);  // 消抖
1190   4              stopwatch_time_miao_2 = 0;  // 时间清零
1191   4              stopwatch_time_miao = 0;
1192   4              stopwatch_time_fen = 0;
1193   4              stopwatch_state = 0;    // 状态置为停止
1194   4              watch_count = 0;
1195   4            }
1196   3          }
1197   2          
1198   2          if(0==K4)//如果按下K4：确认并退出秒表界面，然后返回时钟界面
1199   2          {
1200   3            delay1ms(20);//消抖
1201   3            if(0==K4)//再次检测按键状态
1202   3            {  
1203   4              while(0==K4);//长按停留在此
1204   4              delay1ms(20);//消抖
1205   4              whereNow=0;
1206   4            }
1207   3          } 
1208   2        }
1209   1      }
1210          
1211          void T_display()
1212          {
1213   1        uchar integer_part;    // 整数部分
1214   1        uchar decimal_part1;    // 小数部分1
1215   1        uchar decimal_part2;    // 小数部分2
1216   1        
1217   1        DS18B20_ConvertT();
1218   1        
1219   1        integer_part = (uchar)T;  // 整数部分
1220   1        decimal_part1 = (uchar)((T - integer_part) * 100);  // 小数部分1
1221   1        decimal_part2 = (uchar)((((T - integer_part)*100)-decimal_part1) * 100);  // 小数部分2
1222   1        
1223   1        smg(2,table[integer_part/10]);
1224   1        smg(3,table_dot[integer_part%10]);
1225   1        smg(4,table[decimal_part1/10]);
1226   1        smg(5,table[decimal_part1%10]);
1227   1        smg(6,table[decimal_part2/10]);
1228   1        smg(7,table[decimal_part2%10]);
1229   1        smg(8,0xA7);
1230   1      }
1231          
1232          void T_set()
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 21  

1233          {
1234   1        if(0==whereNow && 0==K4)//如果此时在时钟界面并按下了秒表按键K4
1235   1        {
1236   2          delay1ms(20);//消抖
1237   2          if(0==K4)//再次检测按键状态
1238   2          { 
1239   3            while(0==K4);//长按等待
1240   3            delay1ms(20);//消抖
1241   3            whereNow=5;
1242   3          }
1243   2        }
1244   1        
1245   1        if(5==whereNow && 0==K4)//如果此时在时钟界面并按下了秒表按键K4
1246   1        {
1247   2          delay1ms(20);//消抖
1248   2          if(0==K4)//再次检测按键状态
1249   2          { 
1250   3            while(0==K4);//长按等待
1251   3            delay1ms(20);//消抖
1252   3            whereNow=0;
1253   3          }
1254   2        }
1255   1      }
1256          
1257          void main()
1258          {
1259   1        clockSetLocation=0; //
1260   1        alarmSetOrNot=0;  //
1261   1        alarmSetLocation=0; //
1262   1        cldSetOrNot=0;    //
1263   1        cldSetLocation=0;   //各界面位置标志与是否调整标志初始化为0
1264   1        alarmOnOff=0;   //闹钟默认关闭
1265   1        whereNow=0;     //默认最开始在时钟界面
1266   1        blankCount=shanCount; //
1267   1        normalCount=shanCount;//闪烁计数标志初始化
1268   1        Timer0_Init();  //定时器T0初始化
1269   1        
1270   1        while(1)
1271   1        {
1272   2          is_leap_year(); //判断是否是闰年  
1273   2          if(0==whereNow || 1==whereNow)
1274   2            clock_display();//数码管动态显示时钟界面
1275   2          clock_set();  //调时(与时钟同界面)  
1276   2          if(2==whereNow)
1277   2            alarm_display();  //数码管动态显示闹钟界面
1278   2          alarm_set();  //闹钟设置
1279   2          alarm_exe();  //闹钟执行
1280   2          if(3==whereNow)
1281   2            cld_display();//数码管动态显示日历界面
1282   2          cld_set();    //日历设置
1283   2          if(4==whereNow)
1284   2            stopwatch_display();
1285   2          stopwatch_set();
1286   2          if(5==whereNow)
1287   2            T_display();
1288   2          T_set();
1289   2        }
1290   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4317    ----
C51 COMPILER V9.57.0.0   MAIN                                                              01/06/2026 17:16:15 PAGE 22  

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     79       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
